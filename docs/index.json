[{"authors":null,"categories":[],"content":"Install key programs BLAST+ executables (NCBI commandline tool; https://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Web\u0026PAGE_TYPE=BlastDocs\u0026DOC_TYPE=Download)\nPython distribution v3.x, recommend Anaconda (https://www.anaconda.com/distribution/)\nPython scripts will help automate many tasks below CD-HIT (commandline tool; https://github.com/weizhongli/cdhit/wiki); install is easy if Anaconda has been installed earlier\nconda install -c bioconda cd-hit\nSequence alignment program, recommend Clustal Omega (commandline tool; http://www.clustal.org/omega/) or MAFFT (commandline https://mafft.cbrc.jp/alignment/software/)\nAlignment viewer, recommend AliView (http://ormbunkar.se/aliview/)\nPhylogenetic tree inference program, recommend FastTree (commandline tool; http://www.microbesonline.org/fasttree/)\nPhylogenetic tree viewer, recommend FigTree (well-designed; http://tree.bio.ed.ac.uk/software/figtree/) or Archaeopteryx (for large trees; https://sites.google.com/site/cmzmasek/home/software/archaeopteryx)\nBelow, instructions assume a UNIX like environment; MacOS is one and so is Linux, but Windows is not. Cygwin is a suite of tools that installs under Windows to provide a lot of the same command-like functionality.\nDecide on a namespace/reference database, e.g. UniProt Source for identifiers from, key annotations, etc. Every sequence will (ideally) have an identifier from this source. Collect key proteins: two tiers Tier 1: \u0026ldquo;Guide\u0026rdquo; entries, proteins that are required in the final data set\nCollect as FASTA or name list, e.g. collect_tier1.fa; if identifiers or sequence are not known we will find them using a BLAST search from our reference database below.\nTier-2: POI entries (proteins of interest), prioritise inclusion, but if redundant, choose one\nCollect as FASTA or name list, e.g. collect_tier2.fa; like above, identifiers/sequences will be retrieved using a BLAST search\nDevise a strategy with which a root can be placed in the eventual phylogenetic tree and amend Tier-1 and Tier-2 lists; this might involve having examplars in Tier-1 and Tier-2 that can work as outgroups or anchor points (by reference to published phylogenetic tree of the same family)\nDownload all members of protein family In UniProt, decide on a family identifier, e.g. \u0026ldquo;DapA\u0026rdquo;, and remove questionable entries, e.g. sequence fragments Execute search and download as FASTA, e.g. go to https://www.uniprot.org type in query family:\u0026quot;dapa family\u0026quot; fragment:no, download as FASTA, save as db-100.fa (\u0026ldquo;100\u0026rdquo; because it is 100% of the family.) Create BLAST database makeblastdb (program part of BLASTx suite) on db-100 For example, makeblastdb -dbtype prot -in db-100.fa -out db-100 Create Tier-1 and Tier-2 files Use the BLAST database db-100 to re-generate Tier-1 and Tier-2 files, so they are associated with identifiers and sequences from reference database For example, blastp -db db-100 -outfmt 3 -num_descriptions 1 -num_alignments 0 -num_threads 5 -query collect_tier1.fa -out tier-1.txt -evalue 1e-100; this will find the sequence with the highest similarity to that given, provided it is statistically supported at E=1e-100 Extract sequence identifiers from BLAST report, e.g. grep -e \u0026quot;^[st][pr]\u0026quot; tier-1.txt | cut -d' ' -f1 \u0026gt; tier-1.tab; from this create tier-1.fa Constrain representation of protein family using key proteins Use program such as CD-HIT to filter sequences at different levels of redundancy allowed, e.g. 99%, 95%, 90%, 50% (we call these db-99, db-95, etc)\nFor example, cd-hit -i db-100.fa -c 0.99 -T 5 -o db-99 -d 0 generates a file db-99.clstr; We do not use the FASTA file created by CD-HIT For each sequence similarity \u0026ldquo;cluster\u0026rdquo; identified (in db-99.clstr), keep all Tier-1 entries, when no Tier-1 entries are in the cluster, keep exactly one Tier-2 entry if available; only when no Tier-1 or Tier-2 entries are in the cluster, pick an entry randomly [this step needs to be automated]; from this, create db-99.fa, db-95.fa, etc Make BLAST databases for each redundancy level, db-99, db-95, etc\nmakeblastdb -dbtype prot -in db-99.fa -out db-99 Create datasets Search Tier-1 entries in db-100 including all homologs closer than a given E-value (e.g. 1e-100) For example, blastp -db db-100 -outfmt 3 -num_descriptions 20000 -num_alignments 0 -num_threads 5 -query tier-1.fa -out dataset-99.txt -evalue 1e-100 Extract sequence identifiers from BLAST report, e.g. grep -e \u0026quot;^[st][pr]\u0026quot; dataset-1.txt | cut -d' ' -f1 \u0026gt; dataset-1.tab; from this create dataset-1.fa Mark Tier-1 and Tier-2 entries in dataset, with distinctive labels etc so that they can be searched for later Try different combinations of redundancy levels (db-99, db-95, \u0026hellip;) and E-value thresholds (1e-100, 1e-75, 1e-50, 1e-10, etc) to construct alternative datasets Redundancy level will control how dense the overall sequence composition will be E-value threshold will control how closely we sample around the Tier-1 entries Perform sequence alignment Use multiple sequence alignment program to establish homologous positions between all entries in a dataset\nFor example, clustalo -i dataset-1.fa -o dataset-1.aln --output-order=tree-order --threads=5 --force Inspect alignment to evaluate quality\nFor example, use AliView, zoom out so the whole alignment can be viewed Check for sole-sequence insertions (and deletions), and remove if incorrectly aligned, and disruptive of the the overall alignment; re-run alignment once cleaned\nPerform phylogenetic tree inference Use tree inference program to create an unrooted phylogenetic tree For example, FastTree -nosupport -out dataset-1_unrooted.nwk dataset-1.fa Inspect tree to place a root and to evaluate quality For example, use FigTree or Archaeopteryx Search for markers of Tier-1 and Tier-2 entries to find appropriate place for root, placed at branch point in unrooted tree ","date":1585612800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585612800,"objectID":"b625bdbf1460caa25aa45a1f91360156","permalink":"http://bodenlab.github.io/GRASP-suite/post/protocols/","publishdate":"2020-03-31T00:00:00Z","relpermalink":"/GRASP-suite/post/protocols/","section":"post","summary":"Steps to take to complete ASR","tags":["Ancestral Sequence Reconstruction"],"title":"Workflow ASR","type":"post"},{"authors":null,"categories":null,"content":"GRASP command-line interface (CLI) There is a command-line interface of GRASP that can prove useful if you want to automate tasks, run reconstructions on your own dedicated hardware, and/or access the latest features. This version is essentially a command-line interface to the backend features of the web-based service. It is worth noting that the web-based version has the advantage of a visual user interface, but that also means that it may lack the latest functionality.\nThe command-line version allows access to a variety of indel inference approaches. Beyond the default bi-directional edge encoding (BE), indels are available by either Position Specific (PS), or Simple Indel Coding (SIC). Regardless of encoding, indels can be inferred using either Parsimony (P) or Maximum Likelihood (ML) methods. This gives six methods: PS-P, PS-ML, SIC-P, SIC-ML, BE-P, BE-ML.\nThe command-line version accepts a file with evolutionary rates inferred with the tree, as produced by several tools incl. IQ-TREE2. At the moment the web-based version does not.\nThe command-line interface is implemented in bnkit as a class asr.GRASP.\nasr.GRASP: What can it do? asr.GRASP accepts an alignment (FASTA or Clustal formats) and a phylogenetic tree (Newick format) with concordant labels, to infer ancestor sequences by joint or marginal reconstruction by maximum likelihood. In the process, the program also infers insertion and deletion events, which are internally represented via partial-order graphs; it also identifies the most supported path of sequence inclusions at each ancestor.\nThe program can save all ancestor sequences (in the case of joint reconstruction) or one sequence (in the case of marginal reconstrution; optionally with character state distributions as a TSV file). It can save the partial-order graphs in JSON or as DOT files, which can be visualised with GraphViz. It can also re-save the tree with assigned ancestor labels.\nGRASP was designed primarily for protein sequences but the command-line version incorporates DNA models too. At this stage we have not tested DNA sequence functionality extensively, nor have we developed specific features around DNA sequences (codon-centric analyses, user-provided background stats, etc).\nasr.GRASP: How do I make it work on my computer? First, you will need Java version 8 or newer. Any operating system with Java should work, including Mac OS, MS Windows and Linux.\nThen, you have a choice: you can clone/download bnkit in its entirety. You may need JUnit 5 testing to get everything working; this is only required if you want to run software tests, say if you are a developer.\nAlternatively, just download the pre-compiled version with all indel inference methods bnkit JAR file. This is the 21st of March 2024 version and compiled with a recent version of Java (19).\nWe also offer a version compiled using Java 11.\nOr, the legacy version bnkit JAR file, which we keep to ensure reproducibility of results presented in the original papers.\nasr.GRASP: How do I run it? Download the jar file\nWe suggest that you then follow steps 2 onwards, but likely you can simply run it from the directory to which it was downloaded, e.g. java -jar ~/Downloads/bnkit.jar should produce the help info below.\nCreate a bash script grasp that contains the following two lines, replacing the path with the path to your downloaded jar\n#!/bin/sh java -jar -Xmx16g \u0026lt;/path/to/bnkit.jar\u0026gt; $@ (the -Xmx is optional; see below)\nChange permissions on the bash script\nchmod 755 grasp Place the file grasp where you store your executable files, for example /usr/local/bin mv grasp /usr/local/bin Check that it works grasp -h This will print out the arguments that specifies your input data and options.\nA typical command may look like this\ngrasp -aln 500_2112_dhad_18032019.aln -nwk r_500_2112_dhad_18032019.nwk -out recon_0500.aln -verbose -gap -thr 5 Full help information\nUsage: asr.GRASP [-a | --aln \u0026lt;filename\u0026gt;] [-n | --nwk \u0026lt;filename\u0026gt;] {-o | --output-folder \u0026lt;foldername\u0026gt;} (default is current working folder, or input folder if available) {-i | --input-folder \u0026lt;foldername\u0026gt;} {-pre | --prefix \u0026lt;stub\u0026gt;} {-rf | --rates-file \u0026lt;filename\u0026gt;} {-s | --substitution-model \u0026lt;JTT(default)|Dayhoff|LG|WAG|JC|Yang\u0026gt;} {-t | --threads \u0026lt;number\u0026gt;} {-j | --joint (default)} {-m | --marginal \u0026lt;branchpoint-id\u0026gt;} {--indel-method \u0026lt;methodname\u0026gt;} (select one from BEP(default) BEML SICP SICML PSP PSML) {--supported-path \u0026lt;methodname\u0026gt;} (select one from DIJKSTRA(default) ASTAR) {--nogap} {--nonibble} {--exclude-noedge} {--save-as \u0026lt;list-of-formats\u0026gt;} (select multiple from FASTA CLUSTAL TREE DISTRIB ASR DOT TREES) {--save-all} (saves reconstruction with ALL formats) {--save-tree} (bypasses inference and re-saves the tree with ancestor nodes labelled as per GRASP\u0026#39;s depth-first labelling scheme starting with N0) {--save-poag { \u0026lt;branchpoint-id\u0026gt; } (bypasses inference and saves the input alignment as a POAG (partial order alignment graph of extant sequences under specified ancestor [default N0]) {--time}{--verbose}{--help} Inference is a two-stage process: (1) A history of indel events is inferred by either maximum likelihood or maximum parsimony and mapped onto the tree to determine what positions contain actual sequence content (2) For each ancestral position, the most probable character is assigned to each phylogenetic branch point when performing a joint reconstruction. Alternatively, for each position at a nominated branch point, the probability distribution over all possible characters is inferred when performing a marginal reconstruction. Finally, edges are drawn to represent all inferred combinations of indels to form an ancestor POG with nodes that can form a valid sequence with inferred content; a preferred path through the POG is then inferred, nominating a single, best supported sequence. Mode of character inference: -j (or --joint) activates joint reconstruction (default), -m (or --marginal) activates marginal reconstruction (requires a branch-point to be nominated) --onlyindel disengages the stage of character state inference Required arguments: -a (or --aln) must specify the name of a multiple-sequence alignment file on FASTA or CLUSTAL format -n (or --nwk) must specify the name of a phylogenetic-tree file on Newick format Optional arguments: -o (or --output-folder) specifies the folder that will be used to save output files, e.g. inferred ancestor or ancestors, tree, etc. as specified by format -i (or --input-folder) skips indel inference, and loads a previous reconstruction from specified folder -sa (or --save-as) lists the files and formats to be generated (see below) --save-all nominates all -pre (or --prefix) specifies a stub that is added to result filenames (default is the prefix of the alignment file) -indel (or --indel-method) specifies what method to use for inferring indels (see below) -s (or --substitution-model) specifies what evolutionary model to use for inferring character states (see below) -rf (or --rates-file) specifies a tabulated file with relative, position-specific rates We recommend the use of this generally, but specifically for trees with great distances, and with biologically diverse entries As an example, IQ-TREE produces rates on the accepted format --include-extants means that extants are included in output files (when the format allows) --nogap means that the gap-character is excluded in the resulting output (when the format allows) --nonibble de-activates the removal of indices in partial order graphs that cannot form a path from start to end --orphans de-activates the removal of orphaned indel trees --exclude-noedge removes non-existing edge as an option for parsimony in BEP --verbose prints out information about steps undertaken, and --time the time it took to finish -h (or --help) will print out this screen Files/formats: FASTA: sequences (most preferred path at each ancestor, gapped or not gapped) CLUSTAL: sequences (most preferred path at each ancestor, gapped) TREE: phylogenetic tree with ancestor nodes labelled DISTRIB: character distributions for each position (indexed by POG, only available for marginal reconstruction) ASR: complete reconstruction as JSON, incl. POGs of ancestors and extants, and tree (ASR.json) DOT: partial-order graphs of ancestors in DOT format TREES: position-specific trees with ancestor states labelled Indel-methods: BEP: bi-directional edge (maximum) parsimony BEML: bi-directional edge maximum likelihood (uses uniform evolutionary model akin to JC) SICP: simple indel-coding (maximum) parsimony (based on Simmons and Ochoterena) SICML: simple indel-coding maximum likelihood (uses uniform evolutionary model) PSP: position-specific (maximum) parsimony PSML: position-specific maximum likelihood (uses uniform evolutionary model) Add \u0026#39;*\u0026#39; to method name for less conservative setting (if available) Substitution-models: JTT: Jones-Taylor-Thornton (protein; default) Dayhoff: Dayhoff-Schwartz-Orcutt (protein) LG: Le-Gasquel (protein) WAG: Whelan-Goldman (protein) JC: Jukes-Cantor (DNA) Yang: Yang\u0026#39;s general reversible process model (DNA) Notes: Greater number of threads may improve processing time up to a point when coordination chokes performance; default is 4 threads. Running GRASP requires large memory and in most cases Java needs to be run with the option -Xmx20g, where 20g specifies that 20GB of RAM should be available. ~ This is version 21-Mar-2024 ~ Access through Docker GRASP is available through Docker Hub at gabefoley/grasp\nOnce you have docker installed you can\ndocker run -it -v {full path to where your data is located}:/data gabefoley/grasp grasp -aln /data/{name of your alignment file}.aln -nwk /data/{name of your newick file}.nwk -out /data for example, for me the command looks like (I have test_6.aln and test_6.nwk sitting in a /data folder):\ndocker run -it -v /Users/coolusername/Documents/code/grasp/data:/data grasp-docker grasp -aln /data/test_6.aln -nwk /data/test_6.nwk -out /data This should give you a file, GRASP_ancestors.fasta appearing in folder: /Users/coolusername/Documents/code/grasp/data.\nWhat else? Running the command-line version is typically a quicker affair, at least for smaller reconstructions, but it requires decent hardware. A reconstruction of less than 1,000 sequences should take less than 10 minutes.\nYou can probably run a reconstruction with 10,000 sequences on a server, but how \u0026ldquo;gappy\u0026rdquo; the alignment is will also play a part in deciding this. If the alignment is reasonably clean, a powerful, modern laptop with at least 16GB of memory, can do this in under a day. If the alignment covers a diverse family, you will probably need a lot more memory. We recommend you set the Java heap size to 60GB RAM, which you can using the option -Xmx60000m.\nThe rough estimates above assume you use multiple threads; we recommend 5 or so on decent hardware (--threads 5).\n","date":1583712000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583712000,"objectID":"e5745ebfb6ec52d1d7599224d12f32cb","permalink":"http://bodenlab.github.io/GRASP-suite/project/graspcmd/","publishdate":"2020-03-09T00:00:00Z","relpermalink":"/GRASP-suite/project/graspcmd/","section":"project","summary":"Command line version of GRASP. [Download bnkit.jar](project/graspcmd/archive/bnkit.jar)","tags":["Inference"],"title":"asr.GRASP","type":"project"},{"authors":["Gabriel Foley","Ariane Mora","Connie M Ross","Scott Bottoms","Leander Sutzl","Marnie L Lamprecht","Julian Zaugg","Alexandra Essebier","Brad Balderson","Rhys Newell","Raine ES Thomson","Bostjan Kobe","Ross T Barnard","Luke Guddat","Gerhard Schenk","Joerg Carsten","Yosephine Gumulya","Burkhard Rost","Dietmar Haltrich","Volker Sieber","Elizabeth MJ Gillam","Mikael Boden"],"categories":null,"content":"","date":1577750400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577750400,"objectID":"c2f96fee8fb089d5186c27b788ebb96c","permalink":"http://bodenlab.github.io/GRASP-suite/publication/grasp/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/GRASP-suite/publication/grasp/","section":"publication","summary":"We developed Graphical Representation of Ancestral Sequence Predictions (GRASP) to infer and explore ancestral variants of protein families with more than 10,000 members. GRASP uses partial order graphs to represent homology in very large datasets, which are intractable with current inference tools and may, for example, be used to engineer proteins by identifying ancient variants of enzymes.","tags":["Inference"],"title":"Identifying and engineering ancient variants of enzymes using Graphical Representation of Ancestral Sequence Predictions (GRASP)","type":"publication"},{"authors":[],"categories":null,"content":"","date":1575936000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575936000,"objectID":"c0b78df16a2de909b653d6e73a0b4109","permalink":"http://bodenlab.github.io/GRASP-suite/talk/abacbs/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/GRASP-suite/talk/abacbs/","section":"talk","summary":"Talk at the [International Conference on Genome Informatics \u0026 Australian Bioinformatics and Computational Biology Society](https://www.abacbs.org/conference2019/about) | [Click to download presentation slides.](talk/abacbs/ABACBS_slides.pdf)","tags":[],"title":"Predicting, exploring, and synthesising ancestral sequences using GRASP","type":"talk"},{"authors":[],"categories":null,"content":"","date":1575590400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575590400,"objectID":"008aa653b51dc0707fcafc33bd7cea8a","permalink":"http://bodenlab.github.io/GRASP-suite/talk/inpec_apem/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/GRASP-suite/talk/inpec_apem/","section":"talk","summary":"Talk at the [International Network of Protein Engineering Centres - Australasian Protein Engineering Meeting](https://inpec-apem.wixsite.com/inpec-apem) | [Click to download presentation slides.](talk/inpec_apem/INPEC-APEM-2019.pdf)","tags":[],"title":"Ancestral sequence reconstruction. In your toolkit yet?","type":"talk"},{"authors":[],"categories":null,"content":"","date":1561593600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1561593600,"objectID":"6c696477c8affeb1470c2d8b0dede7c4","permalink":"http://bodenlab.github.io/GRASP-suite/talk/iccp450/","publishdate":"2019-06-27T00:00:00Z","relpermalink":"/GRASP-suite/talk/iccp450/","section":"talk","summary":"Talk at the [International Conference on Cytochrome P450](https://www.iccp450brisbane.com/) |[Click to download presentation slides.](talk/iccp450/Engineering_P450s_slides.pdf)","tags":[],"title":"Engineering cytochromes P450 from ancestral predictons using the novel tool GRASP","type":"talk"},{"authors":["Gabriel Foley","Leander Sützl","Stephlina A D'Cunha","Elizabeth MJ Gillam","Mikael Bodén"],"categories":null,"content":"","date":1560988800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1560988800,"objectID":"31c3c0372cdbaaf2057dd187aeb3df3c","permalink":"http://bodenlab.github.io/GRASP-suite/publication/seqscrub/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/GRASP-suite/publication/seqscrub/","section":"publication","summary":"Data consistency is necessary for effective bioinformatic analysis. SeqScrub is a web tool that parses and maintains consistent information about protein and DNA sequences in FASTA file format, checks if records are current, and adds taxonomic information by matching identifiers against entries in authoritative biological sequence databases.","tags":["Pre-inference"],"title":"SeqScrub: a web tool for automatic cleaning and annotation of FASTA file headers for bioinformatic applications","type":"publication"},{"authors":["Yosephine Gumulya","Jong-Min Baek","Shun-Jie Wun","Raine E. S. Thomson","Kurt L. Harris","Dominic J. B. Hunter","James B. Y. H. Behrendorff","Justyna Kulig","Shan Zheng","Xueming Wu","Bin Wu","Jeanette E. Stok","James J. De Voss","Gerhard Schenk","Ulrik Jurva","Shalini Andersson","Emre M. Isin","Mikael Bodén","Luke Guddat","Elizabeth M. J. Gillam"],"categories":null,"content":"","date":1540166400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540166400,"objectID":"651cb46a7258a7d92705e8dd44d537a0","permalink":"http://bodenlab.github.io/GRASP-suite/publication/engineering_highly_functional/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/GRASP-suite/publication/engineering_highly_functional/","section":"publication","summary":"Commercial biocatalysis requires robust enzymes that can withstand elevated temperatures and long incubations. Ancestral reconstruction has shown that pre-Cambrian enzymes were often much more thermostable than extant forms. Here, we resurrect ancestral enzymes that withstand ~30 °C higher temperatures and ≥100 times longer incubations than their extant forms.","tags":["Ancestral Sequence Reconstruction"],"title":"Engineering highly functional thermostable proteins using ancestral sequence reconstruction","type":"publication"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"04ce73b0c78ff2c68747864583129f03","permalink":"http://bodenlab.github.io/GRASP-suite/tools/seqscrub/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/GRASP-suite/tools/seqscrub/","section":"tools","summary":"Lorem ipsum dolor sit amet consectetur adipisicing elit. Magnam, eius.","tags":["Demo","robotics"],"title":"Artificial Intelligence","type":"tools"},{"authors":null,"categories":null,"content":"GRASP web service GRASP web service was developed to facilitate the steps of performing a reconstruction of ancestor sequences (represented by partial-order graphs) and the exploration, archival and sharing of the output. The service consists of three major parts: an inference engine bnkit written in Java, a web service backend written in Java using the Spring framework and Postgres, and web client functionality written in Javascript. The latter two are contained in the open source project GRASP. GRASP depends on the open source project bnkit.\nGRASP: What can it do? The GRASP web service has a User\u0026rsquo;s Guide that we recommend. You will find it in the menu at the top of the GRASP screen at all times.\nGRASP: How do I make it work on my computer? Use any standard web browser and enter the URL http://grasp.scmb.uq.edu.au. We recommend that you sign up for an account; with an account you will be able to use a lot of features that otherwise are unavailable.\nGraspCmd: How do I run it? Follow the User\u0026rsquo;s Guide.\nWhat else? There is a command-line version to run reconstructions on your local hardware. This version does not have all the features; for instance there is no interactive mode and currently no way of transferring your reconstruction to the web service.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"551709c8b1bd77bb1a923a8294db8d62","permalink":"http://bodenlab.github.io/GRASP-suite/project/grasp/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/GRASP-suite/project/grasp/","section":"project","summary":"GRASP performs ancestral sequence reconstruction | [Use GRASP now](http://grasp.scmb.uq.edu.au) | [Link to repository](http://github.com/bodenlab/grasp)","tags":["Inference"],"title":"GRASP","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"12e4cb29d3a7b82e5813310e2fd876c7","permalink":"http://bodenlab.github.io/GRASP-suite/tools/grasp/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/GRASP-suite/tools/grasp/","section":"tools","summary":"GRASP performs ancestral sequence reconstruction","tags":["Demo","Deep Learning"],"title":"GRASP","type":"tools"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"f95471180d3554187021bf190b187fe7","permalink":"http://bodenlab.github.io/GRASP-suite/project/seqscrub/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/GRASP-suite/project/seqscrub/","section":"project","summary":"SeqScrub cleans and annotates FASTA file headers and phylogenetic trees. | [Use SeqScrub now](http://www.gabefoley.com/seqscrub) | [Link to repository](http://github.com/gabefoley/SeqScrubf)","tags":["Pre-inference"],"title":"SeqScrub","type":"project"},{"authors":null,"categories":[],"content":"Tutorial Click here to access this notebook through GRASP-resources\nThis notebook can be cloned and used locally. See the GRASP-resources repository for full details\n","date":1461110400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1555459200,"objectID":"bf71adc8790f8e65ba7756d161ccf48f","permalink":"http://bodenlab.github.io/GRASP-suite/post/analysis/","publishdate":"2016-04-20T00:00:00Z","relpermalink":"/GRASP-suite/post/analysis/","section":"post","summary":"Jupyter notebook to analyse the effect of data set size on ancestral predictions. Recreates figures from the GRASP paper.","tags":["Ancestral Sequence Reconstruction"],"title":"Fractional distance analysis","type":"post"},{"authors":null,"categories":[],"content":"Tutorial Click here to access the general GRASP tutorial\n","date":1461110400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1555459200,"objectID":"5c5176ab48e675fc285f178ab0f1f038","permalink":"http://bodenlab.github.io/GRASP-suite/post/grasp/","publishdate":"2016-04-20T00:00:00Z","relpermalink":"/GRASP-suite/post/grasp/","section":"post","summary":"Steps through the process of aligning sequences, inferring phylogenetic trees, and using GRASP to predict ancestors. Provides an overview of GRASP's features.","tags":["Ancestral Sequence Reconstruction"],"title":"General GRASP tutorial","type":"post"},{"authors":null,"categories":[],"content":"GRASP user guide Click here to access the GRASP user guide\n","date":1461110400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578614400,"objectID":"c883d3b63e3096881e175e6f3c7eb4bf","permalink":"http://bodenlab.github.io/GRASP-suite/post/userguide/","publishdate":"2016-04-20T00:00:00Z","relpermalink":"/GRASP-suite/post/userguide/","section":"post","summary":"Detailed explanation of the features of GRASP and how to use it.","tags":["Ancestral Sequence Reconstruction"],"title":"GRASP user guide","type":"post"},{"authors":null,"categories":[],"content":"Tutorial Click here to access these notebooks through GRASP-resources\nThese notebooks can be cloned and used locally. See the GRASP-resources repository for full details\n","date":1461110400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578355200,"objectID":"faf075c6b4b0d59d2d8e1a6a0269f33c","permalink":"http://bodenlab.github.io/GRASP-suite/post/curation/","publishdate":"2016-04-20T00:00:00Z","relpermalink":"/GRASP-suite/post/curation/","section":"post","summary":"Jupyter notebook tutorials that give the user an environment to analyse and curate sequence data sets. Includes notebooks for automatic and iterative removal of sequences and notebooks to map and visualise exon structure on multiple sequence alignments.","tags":["Ancestral Sequence Reconstruction"],"title":"Sequence curation tutorials","type":"post"},{"authors":null,"categories":null,"content":"Presentations\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"528472edb32a1c83992c5fc818fb7160","permalink":"http://bodenlab.github.io/GRASP-suite/presentations/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/GRASP-suite/presentations/readme/","section":"presentations","summary":"Presentations","tags":null,"title":"","type":"presentations"}]